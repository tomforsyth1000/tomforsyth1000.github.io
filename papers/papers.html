<title>TomF's talks and papers.</title>
<h1>TomF's talks and papers.</h1>
In rough chronological order, newest first.<br>
<br>
<a href="LRBNI origins v4 full fat.pdf">SMCANI to AVX512 - the life cycle of an instruction set</a> presented at <a href="https://www.handmade-seattle.com/">Handmade Seattle 2019</a> conference. I talk about how we went about creating the 512-bit SIMD extensions to the 80x86 instruction set - starting from its inception as a research project, going through the <a href="../larrabee/larrabee.html">Larrabee</a> project, and into mainstream use as the AVX512 instruction set. This is a longer version than presented, with some details I had to skip in the time available.<br>
<br>
<a href="FDG2015_Oculus_Tom_Forsyth_v3_final.pdf">Virtual Reality as a Medium: Changing Mechanics</a> presented as a keynote talk to the <a href="http://www.fdg2015.org/">Foundations of Digital Games 2015</a> conference. This was my thoughts on how VR as a medium differs from existing 2D-screen-based games in the ways it can communicate with the player. So very few low-level details on coding, hardware or graphics (there's other presentations for that) but more of the higher-level mechanics and the channels of input and output available to designers.<br>
<br>
<a href="Software_Engineering_and_VR_TomForsyth_Stanford_v6_final.pdf">Software Engineering and VR</a> presented to Stanford CS undergrads in January 2015 - sorry, the talk wasn't recorded so no video or audio. There's a little bit about how VR works, but most of it is about development methodologies, so probably quite dry if you're not a full-time coder. Please note that much of it is my personal opinion, and by no means represents a company-wide consensus (if indeed such a thing can exist in any group of coders where N>1)<br>
<br>
<a href="http://www.gdcvault.com/play/1020714">Developing VR Experiences with the Oculus Rift</a> at GDC2014, and slides in <a href="GDC2014_Developing_Virtual_Reality_Games_and_Experiences__Tom_Forsyth_final_with_notes.pptx">PowerPoint</a> or <a href="GDC2014_Developing_Virtual_Reality_Games_and_Experiences__Tom_Forsyth_final_with_notes.pdf">PDF</a> format. Slightly tweaked <a href="https://www.youtube.com/watch?v=addUnJpjjv4">version given at Oculus Connect 2014</a>, with <a href="http://static.oculus.com/connect/slides/OculusConnect_Developing_VR_Experiences_with_the_Oculus_Rift.pdf">PDF slides</a>. This talk is not so much about how to use the Rift SDK, but more about the things games need to change for VR to maintain presence, be kind to the users, and let them be immersed and have a good time.<br>
<br>
<a href="http://www.stanford.edu/class/ee380/ay0910.html">The Challenge of Larrabee as a GPU</a>, given at Stanford 2010. The first half is a very brief intro to programming for <a href="../larrabee/larrabee.html">Larrabee</a> - it was a nice high-level audience, so I could skim a bunch of stuff. The second half was about how we persuaded a mostly general-purpose CPU to "emulate" a GPU at full speed. Click on the icon to the right of the talk title for video. Some great questions afterwards - a boisterous and very knowledgeable audience. <a href="../larrabee/Standford%20Forsyth%20Larrabee%202010.zip">Locally-hosted slides are here.</a><br>
<br>
<a href="../larrabee/Larrabee%20GDC%202009.zip">Rasterization on Larrabee and SIMD Programming With Larrabee</a>: GDC 2009, Michael Abrash and I doing our double-act. We both talk about the instruction sets, Michael talks about the hierarchical descent rasterisation algorithm, and I talk about how we do basic language structures such as conditionals and flow control with our 16-wide vector units. We were both absurdly proud to be able to finally talk about the architecture we'd worked on for so long - it's not every programmer that gets to design their own instruction set.<br>
<br>
<a href="../larrabee/Larrabee%20Siggraph%202008%20Forsyth.zip">Larrabee Graphics Architecture: Software is the New Hardware</a></b>: Siggraph 2008, part of the <a href="http://s08.idav.ucdavis.edu/">Beyond Programmable Shading Course</a>. The basics of how <a href="../larrabee/larrabee.html">Larrabee</a> does in software what everyone else does in hardware, and how it can be more flexible and general than a standard GPU.<br>
<br>
<a href="trilight/trilight.html">Trilights</a> - a very brief paper on a type of light that I've been using for a while that is a generalisation of a bunch of other light types that are common in games. Not exactly earth-shattering - it's hardly a paper at all - but people don't seem to document little tricks like this, so they never get passed along. So I thought I should. Also here are links to the <a href="trilight/trilight_vs_wraparound.xls">Excel spreadsheet</a> and the <a href="trilight/trilight_demo.zip">demo</a> mentioned in the paper.<br>
<br>
<a href="Tom_Forsyth_Shaders_in_engines_GDC2007.ppt.zip">Integrating Shaders into An Engine</a> - GDC 2007 rough guide to managing a pipeline with lots of shaders and platforms. Not meant to be exhaustive or terribly detailed - there are many ways of doing this, and no way is going to work for anything. This introduces the rough structure I have always used, as it scales fairly well and allows near-optimal rendering speed on multiple platforms. (PowerPoint slides)<br>
<br>
<a href="Tom_Forsyth_Shadowbuffers_GDC2007_small.ppt.zip">Yet More Shadowbuffers</a> - GDC 2007 practical guide to the current state of the art in shadowbuffering. Includes a discussion of the research I did using both an 8-bit ID buffer and an 8-bit depth buffer to solve the problems inherent in both methods and make shadows truly robust in all scenes. As an added bonus, it requires no special hardware and only a 16-bit shadowbuffer - two channels of 8 bits. Also includes a very brief discussion of Multi Frustum Partitioning, but I would go read the GDC2006 talk above for a much better guide. (PowerPoint slides)<br>
<a href="Tom_Forsyth_Shadowbuffer_demo_GDC2007.zip">The demo to accompany these slides</a>. I advise reading the slides first, then playing with the demo. If you get a "missing DLL" error, that's probably because this requires the DirectX February 2007 SDK/runtime to run - you should be able to get it from <a href="http://msdn.microsoft.com/directx/">Microsoft</a>. There is a readme.txt inside the zip with the controls.<br>
<br>
<a href="fast_vert_cache_opt.html">Linear-Speed Vertex Cache Optimisation</a> - September 2006 paper on finding a "universal" rendering sequence for near-optimal vertex cache performance, whatever hardware you happen to be running on today. It's the algorithm I developed for <a href="http://www.radgametools.com/gramain.htm">Granny3D</a>'s Mesh Preprocessor, and it gives results within a few percent of the best techniques I know of, but it's much much faster and simpler, which means you could do it at load time, or even at runtime when splicing different meshes together (e.g. Frankensteining different body-parts for an MMO).<br>
<br>
<a href="GDC2006_Forsyth_Tom_ExtremelyPracticalShadows.ppt.zip">Extremely Practical Shadows</a> - Game Developers Conference 2006 talk on using shadowbuffers. The followup to the 2004 talk, but now without wasting half the time on volume shadows and stuff like that. Also talks about various projection methods (PSM, LiPSM, TSM) and how they integrate with the "Multi-Frustum Partitioning" (which I have now made into a proper capitalised term and a TLA for ease of use - because every good algorithm needs a TLA). (PowerPoint slides)<br>
And the same <a href="shadowbuffer_pseudocode.html">details about the algorithm.</a><br>
<br>
<a href="how_to_walk.ppt.zip">How To Walk</a> - a talk given at <a href="http://www.game-tech.com/">GameTech</a> 2004 that started out supposedly as a quick demo to show off some of <a href="http://www.radgametools.com/">Granny</a>'s features, and turned into quite a research project. (Powerpoint slides)<br>
<br>
<a href="demo_engine_to_game_engine.ppt.zip">Demo Engine to Game Engine</a> given at <a href="http://pilgrimage.scene.org/2004/">Pilgrimage 2004</a>. The slides aren't very impressive because this was a quick, informal talk given to a bunch of demo coders. Having been a demo coder myself a long time ago on a platform far far away (the Atari ST) and then moved on to "real" games development, I thought I'd do a talk about the differences between coding up a cool demo engine and writing an engine for a real published game. It's pretty scary.<br>
<br>
<a href="Tom_Forsyth_Practical_Shadows.ppt.zip">Practical Shadows</a> - Game Developers Conference 2004 talk on using shadowbuffers in a real game. In this case, the game in question is <a href="http://www.strategyplanet.com/startopia/">StarTopia</a>, which I retrofitted a robust and fast shadowbuffer system to. I'm rather pleased with the <a href="../startopia/startopia.html">results</a>, considering no art was changed from the original. It's also a brief overview of some of the yays/nays of shadow volumes vs shadow buffers. (PowerPoint slides)<br>
People have asked for <a href="shadowbuffer_pseudocode.html">a few more details about the algorithm discussed in the slides.</a> The public gets what the public wants.<br>
<br>
<a href="SH_GDCE_TomF.zip">Spherical Harmonics in Actual Games</a> - Game Developers Conference Europe 2003 talk on using spherical harmonic irradiance in a real game. Note that here I am only talking about one application of spherical harmonics - the representation of incoming light. Cool extensions such as Precomputed Radiance Transfer go way beyond this and do a lot more with SHs, but in return they are less generally-applicable. (PowerPoint slides). After that, please read the notes and errata that are <a href="../blog.wiki.html#%5B%5BSpherical%20Harmonics%20in%20Actual%20Games%20notes%5D%5D">here</a> - there's a lot more about the implementation and neat side effects.<br>
<br>
<a href="Tom_Forsyth_Self_Shadowing_Bumpmaps.pdf">Self-shadowing Bumpmaps using 3D Texture Hardware</a> - using volume textures to render self-shadowing bumpmaps really really fast. <a href="Tom_Forsyth_Self_Shadowing_Bumpmaps.zip">The paper in PostScript format</a> or <a href="Tom_Forsyth_Self_Shadowing_Bumpmaps.pdf">PDF format with low-rez images</a>. This paper appeared in the <a href="http://www.acm.org/jgt/">journal of graphics tools</a> Volume 7, Number 4, 2002: Special Issue on Hardware Accelerated Rendering Techniques.<br>
<br>
<a href="Displacement_Map_Slides_and_Notes_GDC_2003.zip">GDC 2003 paper on Displacement Mapping</a> co-presented with Michael Doggett of <a href="http://www.ati.com/">ATI</a>. Includes both the slides used during the talk, and some more information in the form of a white paper.<br>
<a href="DispCompDemo.zip">Displacement Compression Demo</a> referred to in the talk. It probably won't mean much without reading my slide deck, so make sure you do that first. Also read the readme.txt in the ZIP for running instructions. Requires a PC with DX9 installed.<br>
<br>
<a href="Tom_Forsyth_Meltdown2001.zip">Highly Scalable Character Rendering</a> - a talk given at Meltdown 2001. This extends the Meltdown 2000 ideas to Vertex Shaders, and introduces a lot of other scalability methods that can be applied to bones, rendering methods, shadowing and so on.<br>
If you have the full PowerPoint app, check out the notes on the slides, as they contain more detail than could be fitted in the slides. Otherwise, check out the text version included in the zip file.<br>
<a href="Meltdown2001_hindsights.html">Some hindsights I had about the Meltdown 2001 talk</a>.<br>
<br>
<a href="Tom_Forsyth_Meltdown2000.zip">Where Have All The Bumpmaps Gone?</a> - presented at Meltdown 2000 (also called "Windows Game Developers Conference"). Paper showing how to use VIPM, displacement maps and smooth surfaces to produce highly detailed and scalable models.<br>
If you have the full PowerPoint app, check out the notes on the slides, as they contain more detail than could be fitted in the slides. Otherwise, check out the text version included in the zip file.<br>
<a href="Meltdown2000_hindsights.html">Some hindsights I had about the Meltdown 2000 talk</a>. Bear in mind that the talk was written when Vertex Shaders had only just been introduced into the API.<br>
<br>
<br>
<br>
<br>
<h1>Tom's books and articles.</h1>
Also in rough chronological order. Because of copyright, most of these cannot be reproduced here - sorry.<br>
<br>
<a href="../larrabee/larrabee_manycore.pdf">Larrabee: A Many-core x86 Architecture for Visual Computing</a></b>: Siggraph 2008. Larrabee's first real showing to the world. The paper was origianlly about twice as long and we had to chop it down severely to fit to the required length. If some things seem overly simplified - that's why. We tried to add the info back in in subsequent presentations.<br>
<br>
<a href="http://www.shaderx5.com">ShaderX5</a> (ISBN 1-58450-499-4 Charles River Media 2007) "Shadows" section editor<br>
<br>
<a href="http://www.shaderx4.com">ShaderX4</a> (ISBN 1-58450-425-0 Charles River Media 2006) "3D Engine Design" section editor, and one chapter in the shadows section titled "Making Shadow Buffers Robust Using Multiple Dynamic Frustums"<br>
<br>
<a href="http://www.charlesriver.com/Books/BookDetail.aspx?productID=99109">Introduction To Game Development</a> (ISBN 1584503777, Charles River Media 2005): I wrote the chapters on Character Animation (actually covers the basics of all animation, not just characters) and Graphics (a painfully short summary of triangle-based real-time rendering). I think this is an extremely useful and concise introduction to the topics for undergraduates and those new to any of the topics within, but I could have easily expanded each of my chapters to an entire book and wanted to write more.<br>
<br>
<a href="http://www.shaderx3.com">ShaderX3</a> (ISBN 1584503572, Charles River Media 2004) - "3D Engine Design" section editor.<br>
<br>
<a href="http://www.shaderx2.com">ShaderX2</a> (ISBN 1556229887, Wordware Publishing, Inc. 2003) chapters:
<ul>
<li>Displacement Mapping: a summary of existing displacement map technologies, the tools required for practical authoring of displacement maps, and a quick guide to my own cheap version of disp.mapping - "displacement compression" that runs on pretty much any hardware (see my Meltdown 2000, 2001, and GDC 2003 talks above for details)</li>
<li>Shader Abstraction: how to integrate complex arbitrary shaders into an existing 3D game engine. It's tougher
than you think.</li>
<li>Post-process Fun With Effects Buffers: how to write an engine with multiple post-processing passes in an orthogonal and extendable manner.</li>
</ul>
<br>
<a href="http://www.charlesriver.com/Books/BookDetail.aspx?productID=18874">Game Programming Gems 3</a> (ISBN 1584502339, Charles River Media 2002) chapters:
<ul>
<li>Cellular Automata for Physical Modelling: a discussion of using cellular automata to model effects such as fire, explosions, wind and water (and combinations thereof - burning oil that flows through the holes it creates!), and various quadtree-based optimisations that use coarse granularity in both space and time steps to reduce the cost of modelling a full 3D space. Shame nobody has actually put this in a game yet - I think this could be a brilliant way to get some superb "real physics" effects. <b>See below for HTML version.</b></li>
<li>Unique Textures: a general method of applying any procedurally-generated texture across a landscape, generating only the textures required for rendering at the specified mipmap levels. I believe a few games have done this, and <a href="http://www.tulrich.com/">Thatcher Ulrich</a> has certainly talked about something similar in the past. But I still see games struggling with large worlds, and this method is so much more applicable than people realise. It's not just for landscapes - it's for everything - even if you just use it to upsample your textures with a cubic or sinc filter rather than the horrible hardware bilinear one.</li>
</ul>
<br>
<a href="http://www.charlesriver.com/Books/BookDetail.aspx?productID=8716">Game Programming Gems 2</a> (ISBN 1584500549, Charles River Media 2001) chapters:
<ul>
<li>Comparison of VIPM Methods: a comprehensive comparison of four methods of View Independent Progressive Meshes. The methods are the "Vanilla" method developed by <a href="http://www.svarovsky.org/jan/">Jan Svarovsky</a> inspired by a <a href="http://research.microsoft.com/~hoppe/">Hugues Hoppe</a> paper, and three others invented by the <a href="http://lists.sourceforge.net/lists/listinfo/gdalgorithms-list">Game Development Algorithms</a> list hive-mind (thankyou all, and I'm sorry I can't remember exactly who invented which bit of what). I implemented all three, and compared their various applicability in different situations - "SkipStrips", "Multi-level SkipStrips" and "Sliding Window". Overall, I highly recommend Sliding Window VIPM as usually being the most efficient of the bunch, and sliding window is the version implemented in the Xbox version of the game Blade II. <b>See below for HTML version.</b></li>
<li>Impostors - Adding Clutter: a discussion of the effective use of dynamically-rendered impostors, as implemented in the PC game <a href="../startopia/startopia.html">StarTopia</a>. In retrospect, impostors worked pleasingly well, with decent speed improvements. I would have been far more aggressive with them if the rendering hardware at the time (GeForce 2 and Radeon 7000 were cutting-edge) had had fast and reliable render-to-texture capabilities. As it was, most of my time was spent working around driver bugs and hardware restrictions. Today's cards can handle impostoring to a far more impressive degree. <b>See below for HTML version.</b></li>
</ul>
<br>


<br>
<h1>HTML versions of older articles.</h1>
I'll add to this over time. Most articles include some hindsights that I've had since writing them.<br>
<br>
<a href="gem_vipm_webversion.html">Comparison of VIPM Methods</a><br>
<br>
<a href="gem_imp_filt.html">Impostors – Adding Clutter</a><br>
<br>
<a href="cellular_automata_for_physical_modelling.html">Cellular Automata for Physical Modelling</a><br>
<br>
<br>
<a href="../index.html">Tom Forsyth Home</a><br>
<br>
<hr>
<br>
I feel kinda silly doing this, but I have actually been asked what the license terms are for stuff you read on this page, and the papers linked from it. Looks like someone actually finds it useful - huzzah! Anyway, here's my cobbled-together license statement. It's a version of the MIT license, as stated in full at <a href="http://www.opensource.org/licenses/mit-license.php">opensource.org</a>, but I removed the bit about <i>requiring</i> attribution.<br>
<br>
Instead I'm going to add here, NOT in legalese because there's probably no good way to state it, that it would be nice if you could add some sort of thanks somewhere. Bonus karma points for doing it in a way that shows up on <a href="http://www.mobygames.com/">Mobygames</a>. Or just buy me a beer at GDC or something. And if you don't, may you be reborn as an Atari Jaguar in a world where Tempest 2000 never existed. Oh, and try to spell my name right - no "e" in Forsyth.<br>
<br>
If anyone finds a better license than this, let me know and I'll probably use that one instead.<br>
<hr>
Copyright (c) 1973-2073, Tom Forsyth<br>
<br>
Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:<br>
<br>
THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.<br>
<br>
<br>
<br>
<br>